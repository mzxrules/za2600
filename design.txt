===============================================================================
> List of todos, ordered by importance
===============================================================================

Bosses:
    Patra
    Ghini
    Glock - Need Design, have sprites
    Dig
    Ganon - Death animation, unlock room on TriPow, delay launch missiles

Enemies:
    Wizrobes - have sprites, need custom room collision routine
    Gel - Fix overtime budget (See EnMove_Card_WallCheck)
    Armos - Make stairs/item appear
    Blue Leevers - need behavior
    Base Enemy - Environment Missile attack?
    Stalfos - Key drop on kill mechanic?
    Zola - Cut?
    Bubbles - Cut?

Systems:
    Second Quest
        * Quest Select at game start
    Dungeon Underground
        * Spawn Keese
    Random Drops
        * TypeB and TypeC drop tables?
        * 8th enemy has the bomb mechanics?
    EnMove_Card_WallCheck
        * Find optimizations
    Enemy Spawns - Second Implementation
        * Re-add spawn reset routine
    Bracelet check
    Status Hud - Complete
    Door Unlock System - Complete
    Raft System - Complete

HIDDEN_CAVE Q1 TODO:
    1C - Armos entry
    21 - Grave magic sword
    3D - Armos entry
    4B - Bush
    4E - Armos Entry
    51 - Bush (more variance)
    63 - Bush
    78 - Bush

Glitches:
    The hitboxes for player missiles are skewed because m0X is used

Level Issues:
    Q1 Level 3 room $69, has bomb drop and stairs east to raft.
    Q1 Level 8 room $37, has bomb drop and stairs east.
    Q2 Level 6 room $14, left room intended to only be accessible with ladder,
    while north part of room is inaccessible with ladder. Fortunately, left
    room is a non-critical path

===============================================================================
> The Game
===============================================================================

Main Game Loop:

    Random
    VerticalSync - HUD Element Positioning Kernel
VERTICAL_BLANK
    RoomUpdate - if RF_EV_LOAD, goto Halt
    Missile System
    PlayerPause - if pause game, goto Pause
    PlayerInput
    PlayerItem
    Check Keydoor unlock
    Update Doors
    Process Audio
    Preconfig Sprites
    Draw HUD
    if TextKernel
        Draw Text
    Draw World
OVERSCAN
    Test Board Exit
    Test Player Collision
    Process ClearDrop
    Process Enemy System
    Process Room Script
    Process Entities
    Process Ball Script
    Update Room Clear
    Update Shutter Door
    Test Game Over
    Overscan Wait
    Update RoomPush


Halt Game Loop:

    VerticalSync
VERTICAL_BLANK
    HtTask_Run
    UpdateAudio
    EnDraw_Del
    Draw HUD
    Draw World
OVERSCAN
    HtTask_Run
    Overscan Wait

When in the main loop, halt can be GOTO'd from these different sections:

* VERTICAL_BLANK
* OVERSCAN


Render Modes:
World + Hud (slow, temps can't be used longterm)
World + No Hud a.k.a "Pause" (faster, less memory)
RSWorld  + Hud (RSWorld draws no sprites)
RSWorld2 + Hud (Same but vertical color scrolling)

===============================================================================
> The World
===============================================================================

The game space is broken down into worlds and then further down into rooms.
There are two different meanings for the term world.

In game, the worldId variable more accurately tracks the current level the
player is in.
    * Bit 0 of the value stores quest type:
        * 0 - Q1, A: First quest
        * 1 - Q2, B: Second quest
    * LV_A0, LV_B0 represents the overworld. These are negative in value
    * LV_A1-LV_A9, LV_B1-LV_B9 are dungeons 1-9. These are positive in value

The second definition of world is linked to rom and ram bank data.

In the level data, there are only three worlds per quest.
    * World 0 stores Q1 Overworld
    * World 1 stores Q1 Levels 1 thru 6
    * World 2 stores Q1 Levels 7 thru 9
    * World 3 stores Q2 Overworld
    * World 4 stores Q2 Levels 1 thru 6
    * World 5 stores Q2 Levels 7 thru 9

Each world stores data for 128 main rooms, which is discussed in detail below.
In game, the roomId variable tracks what room the player is in.
    * $00-$7F map to the main 128 rooms defined in the world
    * $80-$FF are reserved for subworld rooms.

Subworld rooms are locations secondary to a main room.
The two base types of subworld rooms are caves and stairwells.

Caves can only exist in the overworld. Main rooms $00-$7F can transport the
player to a cave room assigned to roomId + $80. This allows caves to have a
"location", and permanent events are stored with the main room's flags.

Stairwells can only exist in dungeons. Unlike caves, stairwell rooms are not
uniquely mapped to roomIds.

===============================================================================
> The World Format
===============================================================================

The data for each room is optimized to fit in 8 bytes per room, or $400 bytes
across 128 rooms (exactly the size of a 1 KB bank). The following information
is stored for each room:

- Room Sprite "pointers" for PF1L, PF1R, and PF2 sprites
- roomDoor, or Door flags, which in dungeons track whether a dungeon door
  should be either open, locked, a shudder door, or a wall.
- roomWA, the room wall flags. In the overworld, these flags combined with
  the room door flags configure the pattern drawn at the wall edges of a
  room. In dungeons, they modify walls to either be bombable or false walls.
- The background and foreground colors of the room.
- Whether a dungeon room's "walls" can be crossed with the hover boots
- Whether a dungeon room should be dark.
- roomRS, RoomScript that should execute while in the room
- roomEX, the RoomScript extra parameter
- roomEN, the room encounter

The Python script world.py is responsible for packing the level editor data.

===============================================================================
> The World Format - Room Sprite and Door Flag packing
===============================================================================

The overworld seems to need more PF2 strips than PF1
Due to the 2 char overlap, PF1 for full 4x2 room sprites tend to be all 0s
Thus to better utilize the room sprite sheet, double the room tile budget to
16 bits, over 3 bytes

Playfield sprites are 16 pixels tall (16 bytes), thus a pointer could be
calculated as

    SpritePtr + (spriteId * 16)

We can pre-compute the mul 16 by storing the 4 least significant bits of the
sprite index in the upper 4, and the most significant 1-2 bits in the lower
1-2 bits. Thus, AND #$F0 gives the pointer's least significant byte, then
AND #$01/#$03 + #>SpritePtr gives the most significant byte.

           LSB!  MSB
PF1 Left:  1111 xxx1
PF1 Right: 1111 xxx1
PF2        1111 xx11
                      unpack algo
Door Flags: xxxx 111x  >> 1
            xxxx 111x  << 4
            xxxx 11xx  << 1

===============================================================================
> The World Format - Door and Wall Flags
===============================================================================

These configure the openings and behaviors for the room's NSEW exits.

The level editor and game implementations differ slightly.
In the level editor, the door flags for a world bank are split into NSEW arrays,
with each byte representing one room's door flags for that particular wall.
This value is a 3 bit maximum enumeration.

When building the game, the enumeration is split into two bytes:
    roomDoors (door flags), which is packed with PF data
    roomWA

both bytes have the same general allocation shown below:

N xxxx xx11
S xxxx 11xx
E xx11 xxxx
W 11xx xxxx

  Zero Capture Shift Masks
N 0xFC  0x03     0
S 0xF3  0x0C     2
E 0xCF  0x30     4
W 0x3F  0xC0     6

The behavior of door and wall flags differ depending on if the world
is an overworld or a dungeon.

Overworld flags:
(E = editor enum, D = roomDoors, W = roomWA)

E   D   W   Wall Type
0  00   0 = None
1  00   1 = Middle
2  01   0 = Wall with 4 pixel centered opening
3  01   1 = Full Wall
4  10   0 = Wall with top or left open
5  10   1 = Wall with bottom or right open
6  11   0 = Wall with 16 pixel centered open (NS only)
7  11   1 = Unused

Dungeon flags:
The door flags have been optimized for dungeons, and directly correspond to how
the wall openings will be drawn.
(E = editor enum, W = roomWA, D = roomDoors)

E   W   D
0  00  00 = open
1  00  01 = keydoor
2  00  10 = shutter door
3  00  11 = wall
4  10  11 = bombable wall
5  11  11 = false wall


===============================================================================
> Rooms - States and Flags
===============================================================================

Room Events: (roomFlags)
    RF_EV_LOAD      ; Triggers Room Load event
    RF_EV_LOADED    ; If set, a new room has been loaded
    RF_EV_ENCLEAR   ; (DELETED) Enemies Cleared event
    RF_NO_ENCLEAR   ; Blocks Enemy Cleared from setting Room Cleared
    RF_EV_CLEAR     ; Room Cleared

Room Special: (roomFlags)
    RF_PF_IGNORE    ; disables playfield collision within room center
;                   ; Enabled in all rooms with PF2 Triforce design
    RF_PF_AXIS      ; allows the player to walk over playfield with boots
;                   ; Enabled in dungeon rooms with RED or WATER colors
    RF_USED_CANDLE  ; stops the blue candle from being used more than once

===============================================================================
> Rooms - RoomScripts
===============================================================================

The complete table of scripts is defined in the RoomScript_Table in ptr.py

RoomScripts (prefix Rs_) are routines used to give behaviors to a room.
Each script has an associated RsInit routine that runs once prior to the room
being drawn. All RsInit routines are required to specify an initial ball
position, even if the element is unused by the main room script.

The roomEX variable is a RoomScript's configurable parameter.

===============================================================================
> RoomScripts - Caves
===============================================================================

On the overworld, there are a number of RoomScripts that define cave openings,
destroyable walls, burnable bushes, warp whistle secrets, etc., all of which
define a custom exit point to a new location using the roomEX value.

The CaveType or CV_* enum actually provides two lists of destinations.
    * The cave subworld room, where the roomEX then configures type
    * A dungeon's first room

As the name suggests, the CaveType enum originally only contained

The cave subworld room is reached by adding/or'ing $80 to the current roomId
which makes it negative, then calling LoadRoom. This room defaults to the
Rs_Cave RoomScript, and further uses roomEX as configured by the main room.

More information about Rs_Cave can be found in Systems - Npcs
The CaveType enum is defined in ptr.py

===============================================================================
> RoomScripts - Stairwells
===============================================================================

In dungeons, RoomScripts that spawn a staircase use roomEX to send you into one
of two stairwell subworld rooms:
    * W1 Room $7F - Rs_Stairwell - a path connecting two rooms together
    * W1 Room $0F - Rs_StairwellItem - a path leading to an item

The StairwellType enum provides definitions for the roomEX values.

For values $00-$7F, you will enter Rs_Stairwell, where one side will take you
to the roomId matching the roomEX value, while the other will take you back
to the current roomId. The two roomIds are compared, and the lower index will
be assigned the left side, while the higher index assiged to the right side,
and the player will be placed nearest the one taking them back to the original
roomId.

For values $80+, you will enter Rs_StairwellItem. roomEX - $80 stores the item
received.

===============================================================================
> Systems
===============================================================================



===============================================================================
> Systems - EnSystem (Enemy System)
===============================================================================

    EnSystem (SUBROUTINE) manages the generation of enemies within a room.
    These are known as encounters. EnSystem proactively spawns one enemy a
    frame until either all entity slots are filled, or the roomENCount limit
    is reached.

    roomEN is an index into a mixed data table of encounters, defined in
    EnSysEncounterTable.
        Byte 0 (rRoomENFlags)
            1000_0000 ; EnType array is length 1
            0001_1111 ; Number of spawns in encounter
        Byte 1+ is the EnType array of enemies.
    In room data/on RF_EV_LOADED, roomEn will point to Byte 0
    EnSystem will transfer that byte to wRoomENFlags and increment roomEN to
    Byte 1. Then with each spawn, roomEn will increment (if applicable).

    Enemies at the start of the array always spawn, while enemies at the end
    may not depending on roomENCount

    roomENCount tracks the number of living enemies. When it reaches 0,
    RF_EV_ENCLEAR will be set. This enables the ClearDrop system

===============================================================================
> Systems - EnSystem - LastDraw
===============================================================================

    EN_LAST_DRAWN   ; Stores 1 if current entity is was given draw priority
                    ; last frame

    In EnDraw_Del, EN_LAST_DRAWN is clear if entity 0 is to be drawn, and set
    if entity 1 is to be drawn.

    Once the frame is rendered, an entity can test against EN_LAST_DRAWN to
    determine if it was drawn that previous frame, and in turn use the prior
    built-in collision result.

    Entity 1 is executed first, which is why EnDraw_Del sets the flag to on
    for Entity 1 being drawn. When swapping to Entity 0, the flag is toggled.

    Entity deletions do not have to be factored into flag state:
        If Entity 1 is deleted that frame, execution simply moves to Entity 0
        If Entity 0 is deleted, the flag becomes desynced, there are no more
            entities to process anyway.

    The following is a logic table to show how EN_LAST_DRAWN (Pri) should
    ideally be set when an entity removes itself.

    Pri = 0, Slot0 = Thing, Slot1 = NONE, DELSLOT0 -> Pri = 1 (Phony State)

    Pri = 0, Slot0 = Thing, Slot1 = Glob, DELSLOT0 -> Pri = 1 (Phony State)
    Pri = 0, Slot0 = Thing, Slot1 = Glob, DELSLOT1 -> Pri = 0

    Pri = 1, Slot0 = Thing, Slot1 = Glob, DELSLOT0 -> Pri = 0
    Pri = 1, Slot0 = Thing, Slot1 = Glob, DELSLOT1 -> Pri = 1

    Pri = 0, Slot0 = Thing, Slot1 = Glob           -> Pri = 0
    Pri = 1, Slot0 = Thing, Slot1 = Glob           -> Pri = 1

===============================================================================
> Systems - Npcs
===============================================================================

All speaking Npcs are coupled to the cave system.

The typical initialization chain is this:
    * enType set to EN_NPC_APPEAR
    * npcType set to the enType for the actor
    * enState is set to NPC_SPR_* and possibly NPC_CAVE

The NPC_CAVE affects how the roomEX flag will be interpreted.
When set, roomEX is expected to contain the CV_* enum
When not set, roomEX contains a MESG_* enum

===============================================================================
> Systems - ItemGet (SUBROUTINE)
===============================================================================

    Sets up Get Item pose
    Sets up Get Item or Get Triforce music sequence
    Gives player an item immediately
    Transforms Entity 0 into EN_ITEM_GET

    EN_ITEM, EN_NPC_GIVE_ONE, EN_NPC_SHOP are the only dependenants


Additionally, the ItemGet system allows for Link to hold items above his head.
Affects EnClearDrop and EnShopkeeper var allocation
enState stores ItemGet trigger, for restoring EnClearDrop and playing MS


===============================================================================
> Halt Game
===============================================================================

Halt Tasks
curRoom -> A
curRoom -> B
RoomLoad nextRoom
Animation N
Animation S
Animation W
Animation E
Return Main

===============================================================================
> Halt Game - PFScroll Proto
===============================================================================

roomIdNext
roomId

Move Dir, roomIdNext - roomId,
N = #-$10 ; 0 curRoom -> B
;           1 RoomLoad nextRoom
;           2 nextRoom -> A
;           3 Animation N:  roomDY starts #ROOM_PX_HEIGHT*2-1 and decs every frame
S = #+$10 ; 0 curRoom -> A
;           1 RoomLoad nextRoom
;           2 nextRoom -> B;
;           3 Animation S:  roomDY starts #ROOM_PX_HEIGHT-1 and incs every frame
W = #-$01 ; 0 curRoom -> A
;           1 RoomLoad nextRoom
;           2 nextRoom -> B
;           3 Animation W:
E = #+$01
I = **    ; 0 curRoom -> A
;           1 RoomLoad nextRoom
;           2 nextRoom -> A
;           3 no animation


===============================================================================
> Enemy Notes
===============================================================================

Darknut Logic:

Directions LRUD, opposes player directions
States:
enStun          ds 1 (non-zero = can't take damage)
enRecoil        ds 1 (non-zero = recoiling)
enBlockedDir    ds 1 UDLR


if collided with pf,
    reset x,y
    if recoil == 0,
        pick new direction

if collided with weapon && stun == 0,
    dec health
    stun = -16
    recoil = -8
    x &= 0xFE //stay on grid
    y &= 0xFE //stay on grid
    //move func handles recoil opposing facing direction

if x & (gridstep-1) != 0 && y & (gridstep-1) != 0,
    continue direction

else if Frame & 0x10
    pick new direction

Move()

Pick Direction:
a = rand()
50% seek player
50% rand dir


Pre:


Post:

if Health = 0, spawn item

Octorok Logic:
    States:
    Init
        set enTimer to N
    Walk
        dec timer
        if timer = 0, Telegraph attack
        else base movement pattern
    Telegraph Attack
        rotate in place N times (0-7 times?)
        at end of state, fire missile
    Attack
        idle N frames

    PlAttack:
        enable recoil
        dec health 1, 2, 4

Leever Logic:
    States:
    Init
    Rise
    Walk
    Sink
    Hide

Stalfos Logic:
    States:
    Walk
        base movement pattern

Gibdos Logic:
    States:
    Walk
        base movement pattern

Rope Logic:
    States:
    Walk
        base movement pattern
        if plX or plY = enX or enY, stalk
    Stalk
        move until collide with wall
        goto walk

LikeLike Logic:
    States:
    Walk
        base movement pattern
    Succ
        lock player position until dead

Moblin Logic:
    Walk
        base movement pattern
    Telegraph Attack
        idle N frames
        at end of state, fire missile
    Attack
        idle N frames

WizrobeA Logic:
    States:
    Wait
        idle N frames, invisible
        end of state, spawn on player's x or y lines
    Phase In
        flicker sprite on/off
    Attack
        fire missile
        idle N frames
    Phase Out
        flicker sprite on/off

Glock Logic:
    Glock is a three headed monster. After the first head takes enough damage,
    it is severed and will freely roam the room

    Intro
    Telegraph

    Attack

Glock Head Logic:


Input repeat prevention:

INPT4 == $00 ; fire button pressed
INPT4 == $80 ; fire button not pressed

if last button == not pressed && button == pressed && ItemTimer == 0
    ItemButton

    1 && 0 && 0


1111 0111 -9
1111 1000 -8
1111 1001 -7
1111 1010 -6
1111 1011 -5
1111 1100 -4
1111 1101 -3
1111 1110 -2
1111 1111 -1
0000 0000  0


set "p_up" "('p_up'+1*('key_pressed'=273o'key72'))"

Position ALL Objects
need x range 0-136 ($88)
10 x 15 gets 0-149
9 x 15 gets 0-134
10 * 5 -1 = 49 cycles, 68 cycles remain

-8, -7, -6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7


  7,   6,   5,   4,   3,   2,   1,   0
111, 110, 101, 100, 011, 010, 001, 000
000, 001, 010, 011, 100, 101, 110, 111


Health Display
1-8 = 1 heart
9-16 = 2 hearts
17-24 = 3 hearts
  -64 = 8 hearts
65-72 = 9 hearts
73-80 = 10 hearts

LoadRoom is running out of scanlines
Overworld timing:
start  3.0
end   25.44
Dungeon timing:
start 3.15
end  26.27

KeydoorCheck -> Kernel Main loop
     1.63
    14.06


Enemy Spawn Routine:

PF1L is normal, so bit 0x80 is left, 0x01 is toward center
PF2 is mirrored, so bit 0x80 is center, 0x01 is left/right
PF1R is "mirrored" so bit 0x80 is right, 0x01 is toward center
PF is 4 units per bit, 0x40 is center x, 0x48 is top, 0x10 is bottom ("2x2" sprites)
With standard "2x2" sprites We can force PF2 spawns to only be on the "grid",
using these bit patterns:

0x80 -> x = +-0x00 + 0x40
0x60 -> x = +-0x08 + 0x40
0x18 -> x = +-0x10 + 0x40
0x06 -> x = +-0x18 + 0x40

4 PF2 checks

for y component:

0 = 0x14
1 = 0x1C
2 = 0x24
3 = 0x2C
4 = 0x34
5 = 0x3C
6 = 0x44

Vertically, I think I want to avoid spawning enemies on the first/last pf line;
this gives us 13 possible vertical spawn positions, 7 if we do "on grid" spawns

In total, that's 28 PF2 spawn points

For PF1 spawns, these bit patterns are "on grid"

0x06 -> x = +-0x28 + 0x40
0x18 -> x = +-0x30 + 0x40

That's 14 PF1 spawn points, or 28 total

Together, it makes 56 spawn checks

Algo time!

8 x pos, 7 y pos: 3 bits x, 3 bits y

x bits:

0?? PF2 check
0xx PF2 check type
1?? PF1 check
10? PF1L
11? PF1R
1?x PF1 check type

y bits:
if 7 -> 3, then
0-6 = line * 2 + 1


===============================================================================
> Systems - Generalized Entity Room Collision Check
===============================================================================

Spawning:

enNX - Next Target, 4x4 grid x
enNY - Next Target, 4x4 grid y

enNX, enNY set to initial spawn pos

Movement:
If thisX,thisY = enNX, enNY; NextDir


8x8 Entities can only exist on points
x = $04 to $7C
y = $08 to $50

Real world pixel is 4x4, giving us
x = 31 steps player, 27 other
y = 19 steps player, 15 other

x = $20 stradle PF1L, PF2 (test 0th bit for both)
x = $60 stradle PF1R, PF2
x <= $1C is PF1L (bit 7 -> 0)
x >= $24 and <= $5C is PF2 (bit 0 -> 7 -> 0)
x >= $64 is PF1R (bit 0 -> 7)

Start by handling $20, $60 special case
if $20 bit set
    $20 case if v flag not set
    $60 if v flag set
else


Text:
load text into ram via loop
 36.48
 40.55
unroll once
 36.48
 39.71

Items:
Rupees 1x, 5x
R. Heart
Fairy
Bombs
-- End of Random Drops --
Key
Triforce
Sword, White Sword
Master Sword
Candle (Red Blue?)
Rock Sirloin
Pegasus Boots (ladder)
Red Ring, Blue Ring
Potion
Raft
Magic Key
Bow
Arrow, Silver Arrow
Bracelet, Bracelet Lv2
Recorder?

; ASM TRICKS
sbc = adc(~arg)
; dec to target amount
    lda #$00 ; <- Target Value
    cmp v
    lda v
    sbc #$0
    sta v

; inc to target amount+1
    lda #$00 ; FF loops indefinitely
    cmp itemRupees
    lda itemRupees
    sbc #$FF
    sta itemRupees


===============================================================================
> Other - Text24
===============================================================================

Text24 draws 24 characters on a line every 2 frames, but it consumed most of
the rom I budgeted for text, without even storing text in the rom yet. It also
used 24 bytes of ram, which is a ton. when i looked at the code, i discovered
two subroutines, one for frame 1, one for frame 2, which were nearly identical.
The main difference was that one needed a 4 cycle delay while the other needed
a 6 cycle delay to position the sprite data correctly. I was able to
deduplicate the code by using the overflow flag to store whether the delay
should be 4 or 6 cycles long. A branch takes 2 cycles to execute, 3 if the
branch is taken, and so a pair of bvs is enough to implement a variable cycle
delay of 4/6 cycles.

===============================================================================
> Unsorted Notes - Cave Info
===============================================================================

money making game

1/3, 1/3, 1/3

loserA is always -10
loserB is 50/50 -40 or -10
winner is 50/50 +20 or +50

win, -10, lose
-10, win, lose

win, lose, -10
lose, win, -10

-10, lose, win
lose, -10, win

  1    1    1    1    1    1
+50, +20, -10, -10, -10, -40

20    8    -4   -4   -4  -16
25   10    -5   -5   -5  -20


Secret
    Warp
    Hint
    Money
Shops
    B Pot,  Fairy,  R Pot
    Key,    Ring,   Meat
    Shield, Bomb,   Arrow
    Shield, Meat,   Heart
    Shield, Key,    Candle


===============================================================================
> Unsorted Notes - Memory Mapping (E7 -> 3E+ conversion)
===============================================================================

Ram

WorldKernel $ 90
PF          $ 3C
RoomClear   $ 20 for 256 rooms
RoomFlag    $100

Rom

World Data could be packed into $400 bytes per 128 rooms,
instead of $800 per 256. This could require less bank switching

Cart Ram Map Info:

General Layout

 A = F000 - Free
 B = F400 - Free
 C = F800 - World # Ram
 D = FC00 - "Always" bank

 Drawing

 A = F000 - Text Kernel A / Shop Kernel    / Sprites (Draw)
 B = F400 - Text Kernel B / Sprites (Shop) / Draw Kernel
 C = F800 - World # Ram
 D = FC00 - "Always" bank


===============================================================================
> World Editor
===============================================================================

The za2600 world editor was created using MegaZeux, a game creator program.
You can find a MegaZeux at digitalmzx.com. The editor requires at least
MegaZeux 2.93d to run.

Within MegaZeux, press L to open the Load World dialog, and navigate to the
za2600 folder. Select atari.mzx in the menu and press enter.
With the title board displayed, press P to start the za2600 world editor.

Alternatively, you can press E to make changes to atari.mzx, but this requires
experience with MegaZeux's world editor.

===============================================================================
> World Editor - Controls
===============================================================================

1, 2, 3, 4 - Change N/S/W/E room door
Q, W, E - inc Room Tile  Left, Mid, Right
A, S, D - dec Room Tile  Left, Mid, Right
R, T    - inc, dec Room Script
F, G    - inc, dec, Room Ex
6, 7    - inc, dec, Room EN
I       - Enable Dark Room Editor (Space to toggle room)
O       - Toggle Palette
P       - Save
M       - switch active world
L       - Set Doorflags (4 char string of chars 0-3)
Z       - copy tile
Space   - place copied room
C       - Set room colors (hex code)
Delete  - Delete room

Editing Notes:

* DO NOT USE MegaZeux's built-in save game feature to save changes.
* Certain edits to ptr.py will cause editor bindings to desync. To fix this:
  * Return to the za2600 world editor title board
  * Run make (this runs ptr.py and generates new editor bindings)
  * Reload the world editor by pressing P on the title board
  * Press P again to save the za2600 world.
  * Run make again.

===============================================================================
> Systems - Atan2
===============================================================================

table lookup:
    dx = plX - mX
    dy = plY - mY

    if dx is negative
        xsign |= $80
        negate dx

    if dy is negative
        ysign |= $40
        negate dy

    while (dx > 7 or dy > 7)
        dx >>= 1
        dy >>= 1

    index = y * 8 + x
    index |= xsign
    index |= ysign

    if x == 0, inc y by $100 ; Solves Atan2 being undefined for 0/0
    else if y == 0, inc x by $100

Rs_Maze
 roomEX 0 is N,N,N,N to Level 5
 roomEX 1 is N,E,S,E to graveyard


===============================================================================
> Systems - Battle System
===============================================================================

Battle algo:

Check if weapon hitbox overlaps enemy hitbox

0, 1, 2, 3, 5

Sword - Direction and Timer
    frames -7 to -2 // same as Arrow
    EW hitbox is 8x2
    NS hitbox is 2x8
    frame -1 // possibly not needed?
    EW hitbox is 4x2
    NS hitbox is 2x4

Bomb - Timer, swap between 4x4 and 8x8 hitbox
Arrow - Direction
    EW hitbox is 8x2
    NS hitbox is 2x8
Fire - Simple 4x4 hitbox
Flute - No Hit
Wand -> Sword then Fire?
Meat - No Hit
Potion - No Hit


Hitbox system:

To test if two boxes AA and BB overlap:
    if AA.x > BB.x - AA.w:
    if AA.x < BB.x + BB.w:
        # x axis pass

Another way to compute it:
    (u8)(AA.x + AA.w-1 - BB.x) < (AA.w + BB.w-1)

HbGetPlAtt: Fetches current player attack and it's hitbox

Battle Weapons:

sword (1, 2, 3)
shield (1, 2)
arrow (1, 2)
fire
wave
bomb
wand
Boomerang


===============================================================================
> Systems - The World View
===============================================================================

Due to the complexities involved with positioning sprites on the Atari 2600,
the world view coordinate system follows what fits best for rendering, over
what one might consider to be a "sensible" way to map the screen space.

As of Jan 8th, 2026 this is how the things work.

The intended maximum visible world view is 160 scanlines tall, rendered on
scanlines 66 to 225 inclusive, with overdraw on scanlines 65 and 226.
With the world kernel being a two line kernel, the pixel precision is halved
to 80 units maximum, a kernel iterator range of 79 to 0.

The Atari 2600 outputs 160 color pixels per scanline, but there are a couple
of things limiting how the space is used.

The playfield is one factor. On the Atari 2600, PF0, PF1, PF2 are combined to
draw 40 "playfield" pixels, with one being 4 color pixels each. Due to limits
on computation, PF0 goes unused. This makes for a minimum play area range
between 16 to 143.

The other issue is x positioning all 5 sprites. The generic algorithm for
x positioning takes 1 or 2 scanlines due to having to set the coarse position
late in the scan cycle. By reducing the number of valid x positions,
PosWorldObjects can set the positions of all 5 sprites in a fixed number
of cycles (which is a little over 6 scanlines).

===============================================================================
> Systems - The World View - Coordinate System Variables
===============================================================================

plX, plY (player render object and position)
enX, enY (enemy render object)
blX, blY (ball render object and position)

en0X, en0Y / en1X, en1Y (enemy 0 and 1 position)

The above store the left, bottom position of the sprite.
A position of (0, 0) would place the sprite at
x = color pixel 12
y = scanlines 240-241 / kernel iterator of -8


m0X, m0Y (player missile render object and collider position)
m1X, m1Y (enemy missile render object)

The above stores left, bottom position of the sprite.
A position of (0, 0) would place the sprite at
x = color pixel 11
y = scanlines 240-241* / kernel iterator of -8

m1Y is drawn to scanlines 239-240

m0X and m1X needs to be +1 over mi0X to properly overlap bottom left player pixel.
m0Y does not need to be adjusted, but the missle will appear 1 scanline above.
Kernel limitations make it impossible for sprites to align perfectly.


mi0X, mi0Y / mi1X, mi1Y (enemy missile sprite 0 and 1 position)

Stores the lower left position of an 8x8 missile sprite. This is done so
that displacement calculations can be simplified regardless of the true size
of the missile.


===============================================================================
> Systems - Enemy Missile System
===============================================================================

miType stores missile type and damage
 & 0F is missile type
    types 0-7 are blocked by small shield
    types 8-F are only blocked by magic shield
 & F0 is 4-bit signed damage in quarter hp increments (only negative values are valid)

===============================================================================
> Systems - Player Recoil
===============================================================================

Opposite plDir when colliding with enemies
Direction when colliding with projectiles is based on this algo:

    compute deltaX
    compute deltaY
    If plOffGrid x,y = 0
        compare absDeltaX with absDeltaY
            greater distance sets direction
            equal distance use opposite plDir


    Else if plOffGrid x = 0
        sign of delta y sets direction
    Else if plOffGrid y = 0
        sign of delta x sets direction


===============================================================================
> Pause Screen
===============================================================================

===============================================================================
> Pause Screen - Tri Sprite
===============================================================================

The large tri is broken up into 8 segments that light up when the corresponding
tri piece is collected from levels 1-8

/|\ 1, 2 (top)

/| |\ 3, 4 (second row)

square left
__
\| 5

|\ 6

square right
__
|/ 7

/| 8

The complete 32x16 image is created using the classic alternating sprite trick
used in 48 px kernels, splitting it into 4 sprite strips (0, 1, 2, 3).
Enabling REFP1 reduces the number of 8x16 sprites needed to draw all 256 states
 * strips 0 and 3 display 1 tri piece each, requiring 2 sprites.
 * strips 2 and 1 display 3 tri piece each, requiring 8 sprites.

===============================================================================
> Pause Screen - Dungeon Map
===============================================================================

The basic sprite pattern for a dungeon room:

  0
 000  000
00000 000
 000  000
  0

Map image must be 48 pixels. Each room info is 5x5, 8 rooms per row.
Dungeon data is 16 rooms per row.
Level 3 (E) is only dungeon spanning both 0-7 and 0-F row indices


ItemKey x positions:
 0: $0C 12.0
 1: $12 18.933333333333334  (20)
 2: $19 25.866666666666667  (24)
 3: $20 32.8                (32)
 4: $27 39.733333333333334  (40)
 5: $2E 46.666666666666664  (48)
 6: $35 53.6                (52)
 7: $3C 60.53333333333333   (60)
 8: $43 67.46666666666667   (68)
 9: $4A 74.4
10: $51 81.33333333333333
11: $58 88.26666666666667
12: $5F 95.2
13: $66 102.13333333333334
14: $6D 109.06666666666666
15: $74 116.0


===============================================================================
> Boss Ganon Kernel
===============================================================================

en0Y between $10 to $38
$10 is Y of $27 to $8
$38 is Y of $4F to $30

en0Y between $10 to $30

en0X is between $0C and $54 -> 5C
it's more idea to start support at $0D

TIMING NOTES:

enX = $0D-$15, then on cycle 33 a sta GRP1 (3) has no glitches
enX = $22-$2A, then on cycle 40 a sta GRP1 (3) has no glitches
enX = $25-$2D, then on cycle 41 a sta GRP1 (3) has no glitches (write effect 44.1?)

Full pattern table:

cycle 33 - $0D-$15 0 k33
cycle 36 - $16-$1E 1 k36-39
cycle 39 - $1F-$27 2 k36-39
cycle 42 - $28-$30 3 k42-45
cycle 45 - $31-$39 4 k42-45
cycle 48 - $3A-$42 5
cycle 51 - $43-$4B 6
cycle 54 - $4C-$54 7
cycle 57 - $55-$5D 8
cycle 60 - $5E-$66 9

spr1x $25 >
PixPos 49 cycle 39.0 to PixPos 56 cycle 41.1, spr2x = $35, PixPos 65 cycle 44.1
spr1x $2D >
PixPos 57 cycle 41.2 to PixPos 64 cycle 44.0, spr2x = $3D, PixPos 73 cycle 47.0


plY $0C = 217 px

===============================================================================
> Legacy Systems - ClearDrop
===============================================================================

The ClearDrop system enables the spawning of Stairs and Items after EnSystem
completes. Because it was written prior to the two entity system, it implements
it's own type system, process scheduling, and draw scheduling systems.

We want to re-work this system to achieve these goals:
    * Stairs can appear during EnSystem and function correctly
    * Random Item drops can be spawned during EnSystem
    * Key Items and Stairs are not a shared entity

ClearDropSystem (SUBROUTINE):
    ClearDropSystem implements two slots, cdAType and cdBType
    cdAType = Stairs / Key Items
    cdBType = Random Item Drops

    System waits for (enType = EN_NONE) and (#RF_EV_ENCLEAR | #RF_EV_CLEAR)
    Then, it sets enType to EN_CLEAR_DROP and initializes
        enState, cdBTimer, cdAType, cdBType to 0
        On #RF_EV_ENCLEAR, cdBType is set to CD_ITEM_RAND instead
    After, ClearDropSystem is complete and allows other systems to take over
    entity EN_CLEAR_DROP.

    RoomScript configures cdAType, waiting for enType to be EN_CLEAR_DROP
    EnSysEnDie assigns cdBX,cdBY to enX,enY when EnSystem completes.
        But it also sets enType to EN_NONE, letting ClearDropSystem initialize
        the other data

EnClearDrop (Entity EN_CLEAR_DROP, CLASS_EN_NPC):
    Process previous frame's collision
         if #CD_LAST_UPDATE indexes an inactive actor, skip

    Set CD_UPDATE_A, CD_UPDATE_B based on cdA/BType being non-zero

    if CD_UPDATE_A, CD_UPDATE_B == 0 rts

    if CD_UPDATE_A, not CD_UPDATE_B, run CD_UPDATE_A x == 1

    if not CD_UPDATE_A, CD_UPDATE_B, run CD_UPDATE_B x == 1

    if CD_UPDATE_A and CD_UPDATE_B
        a = Frame & 1
        if a == 0, run CD_UPDATE_A, x == 2
        else run CD_UPDATE_B, x == 2


===============================================================================
> Legacy Systems - keydoor id system considered during 4k days
===============================================================================

Zero mask used to ID keydoor unlocked flag
Unlock flag lookup table:
RoomA, RoomB, MaskA, MaskB

RoomA is south or east only
RoomB is north or west only

The above is rather complex. Gonna scrap that for keydoors at least
Instead, RAM banks 1-3 store room flags


===============================================================================
> Legacy Systems - Caves
===============================================================================

   EX bits
   $FC = Cave Type/MesgId
   $03 = Variable

   Shop masks are overlapped
   $FC = Shop Type ($10, $14, $18)
   $0F = Shop Inventory



===============================================================================
> Unsorted Notes
===============================================================================

Atari quirks

With 3E+ ram, you are not to cross page boundaries when writing back.
This is due to STA triggering a phantom read.

In Stella, this will trigger as trap RWP [@ memory] instruction


renames

b/pause_menu_map.asm -> Pause_PlotMap
gen/pause_map.asm -> Pause_PlotMapRow