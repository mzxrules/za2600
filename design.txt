List of todos, ordered by importance

Status Hud - Needs selected item indicator/possibly improve hp sprite
Event System
Door Unlock System - Complete
Ganon Fight Kernel
Exits - Complete
Raft System - Complete
Enemy Spawns - First Implementation
Wizrobes
Stalfos
Bubbles
Keese
Bosses

Game Loop:

    RoomLoad
    if not RoomLoad:
        PlayerInput
        Random
        PlayerItem logic
    Check Keydoor unlock
    Update Doors
    Process Audio
    Process Entity
    Preconfig Sprites
    Draw HUD
    if TextKernel
        Draw Text
    Draw World
    Test Board Exit
    Test Player Phases through walls / collision reset
    Process ClearDrop
    Process Enemy System
    Process Room Script
    Process Ball Script
    Update Room Clear
    Update Shutter Door
    Test Game Over
    
Room Events:
    RF_LOAD_EV      ; Triggers Room Load event
    RF_LOADED_EV    ; If set, a new room has been loaded
    RF_ENCLEAR_EV   ; Enemies Cleared event
    RF_NO_ENCLEAR   ; Blocks Enemy Cleared from setting Room Cleared
    RF_CLEAR        ; Room Cleared

Darknut Logic:

Directions LRUD, opposes player directions
States:
Stun        ds 1 (non-zero = can't take damage)
Recoil      ds 1 (non-zero = recoiling)
BlockDir    ds 1 UDLR


if collided with pf, 
    reset x,y
    if recoil == 0,
        pick new direction

if collided with weapon && stun == 0,
    dec health
    stun = -16
    recoil = -8
    x &= 0xFE //stay on grid
    y &= 0xFE //stay on grid
    //move func handles recoil opposing facing direction  
        
if x & (gridstep-1) != 0 && y & (gridstep-1) != 0, 
    continue direction
    
else if Frame & 0x10
    pick new direction

Move()

Pick Direction:
a = rand()
50% seek player
50% rand dir


Pre:


Post:

if Health = 0, spawn item

Octorok Logic:
    States:
    Init
        set enTimer to N
    Walk
        dec timer
        if timer = 0, Telegraph attack
        else base movement pattern
    Telegraph Attack
        rotate in place N times (0-7 times?)
        at end of state, fire missile
    Attack
        idle N frames
        
    PlAttack:
        enable recoil
        dec health 1, 2, 4
        
Leever Logic:
    States:
    Init
    Rise
    Walk
    Sink
    Hide

Stalfos Logic:
    States:
    Walk
        base movement pattern
        
Gibdos Logic:
    States:
    Walk
        base movement pattern
        
Rope Logic:
    States:
    Walk
        base movement pattern
        if plX or plY = enX or enY, stalk
    Stalk
        move until collide with wall
        goto walk
        
LikeLike Logic:
    States:
    Walk
        base movement pattern
    Succ
        lock player position until dead

Moblin Logic:
    Walk
        base movement pattern
    Telegraph Attack
        idle N frames
        at end of state, fire missile
    Attack
        idle N frames
        
WizrobeA Logic:
    States:
    Wait
        idle N frames, invisible
        end of state, spawn on player's x or y lines
    Phase In
        flicker sprite on/off
    Attack
        fire missile
        idle N frames
    Phase Out
        flicker sprite on/off

Input repeat prevention:

INPT4 == $00 ; fire button pressed 
INPT4 == $80 ; fire button not pressed 

if last button == not pressed && button == pressed && ItemTimer == 0
    ItemButton
    
    1 && 0 && 0
    
    
1111 0111 -9    
1111 1000 -8
1111 1001 -7
1111 1010 -6
1111 1011 -5
1111 1100 -4   
1111 1101 -3
1111 1110 -2
1111 1111 -1
0000 0000  0


== World Tiles ==
The overworld seems to need more PF2 strips than PF1
Due to the 2 char overlap, PF1 for full 4x2 room sprites tend to be all 0s
Thus to better utilize the room sprite sheet, double the room tile budget to 16 bits, over 3 bytes

Playfield sprites are 16 pixels tall (16 bytes), thus a pointer could be calculated as

    SpritePtr + (spriteId * 16)

We can pre-compute the mul 16 by storing the 4 least significant bits of the
sprite index in the upper 4, and the most significant 1-2 bits in the lower
1-2 bits. Thus, AND #$F0 gives the pointer's least significant byte, then
AND #$01/#$03 + #>SpritePtr gives the most significant byte. 

           LSB!  MSB
PF1 Left:  1111 xxx1
PF1 Right: 1111 xxx1
PF2        1111 xx11
                      unpack algo
Door Flags: xxxx 111x  >> 1
            xxxx 111x  << 4
            xxxx 11xx  << 1


== Door Flags ==
These configure the openings (or lack of) for the room's NSEW exits.

N xxxx xx11
S xxxx 11xx
E xx11 xxxx
W 11xx xxxx

Overworld flags:
00 = full open
01 = middle blocked
10 = middle open
11 = full wall

Dungeon flags:
00 = open
01 = keydoor
10 = shutter door 
11 = wall

  Zero Capture Shift Masks
N 0xFC  0x03     0
S 0xF3  0x0C     2    
E 0xCF  0x30     4
W 0x3F  0xC0     6

Zero mask used to ID keydoor unlocked flag
Unlock flag lookup table:
RoomA, RoomB, MaskA, MaskB

RoomA is south or east only
RoomB is north or west only

The above is rather complex. Gonna scrap that for keydoors at least
Instead, RAM banks 1-3 store room flags

== Room Special ==
RF_PF_IGNORE disables playfield collision within room center
 Enabled in all rooms with PF2 Triforce design
RF_PF_AXIS allows the player to walk over playfield with boots
 Enabled in dungeon rooms with RED or WATER colors 

set "p_up" "('p_up'+1*('key_pressed'=273o'key72'))"

Position ALL Objects
need x range 0-136 ($88)
10 x 15 gets 0-149
9 x 15 gets 0-134
10 * 5 -1 = 49 cycles, 68 cycles remain

-8, -7, -6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7


  7,   6,   5,   4,   3,   2,   1,   0
111, 110, 101, 100, 011, 010, 001, 000
000, 001, 010, 011, 100, 101, 110, 111 


Health Display
1-8 = 1 heart
9-16 = 2 hearts
17-24 = 3 hearts
  -64 = 8 hearts
65-72 = 9 hearts
73-80 = 10 hearts

LoadRoom is running out of scanlines
Overworld timing: 
start  3.0
end   25.44
Dungeon timing:
start 3.15
end  26.27

KeydoorCheck -> Kernel Main loop
     1.63
    14.06

ClearDrop System:

Two slots: A, B 
Stairs / Key Items, Random Item Drops

RoomScript configures A, EnemySystem configures B
RoomScript will wait for enType to be #EnClearDrop

On EnSysEnDie, set enType to #EN_NONE
Set cdBX/cdBY to enX/enY


The ClearDrop system will init the rest of the system on #RF_ENCLEAR_EV

If enType == #EN_NONE and (roomFlags & (#RF_ENCLEAR_EV or #RF_CLEAR))
    set enType to #EnClearDrop
    zero enState, cdBTimer, cdAType, cdBType
    if #RF_ENCLEAR_EV
        set cdBType #CD_ITEM_RAND 

EnClearDrop:
    Process previous frame's collision
         if #CD_LAST_UPDATE indexes an inactive actor, skip

    Set CD_UPDATE_A, CD_UPDATE_B based on cdA/BType being non-zero
    
    if CD_UPDATE_A, CD_UPDATE_B == 0 rts
    
    if CD_UPDATE_A, not CD_UPDATE_B, run CD_UPDATE_A x == 1
    
    if not CD_UPDATE_A, CD_UPDATE_B, run CD_UPDATE_B x == 1

    if CD_UPDATE_A and CD_UPDATE_B
        a = Frame & 1
        if a == 0, run CD_UPDATE_A, x == 2
        else run CD_UPDATE_B, x == 2
    
Enemy Spawn Routine: 

PF1L is normal, so bit 0x80 is left, 0x01 is toward center
PF2 is mirrored, so bit 0x80 is center, 0x01 is left/right
PF1R is "mirrored" so bit 0x80 is right, 0x01 is toward center
PF is 4 units per bit, 0x40 is center x, 0x48 is top, 0x10 is bottom ("2x2" sprites)
With standard "2x2" sprites We can force PF2 spawns to only be on the "grid",
using these bit patterns:

0x80 -> x = +-0x00 + 0x40
0x60 -> x = +-0x08 + 0x40
0x18 -> x = +-0x10 + 0x40
0x06 -> x = +-0x18 + 0x40

4 PF2 checks

for y component:

0 = 0x14
1 = 0x1C
2 = 0x24
3 = 0x2C
4 = 0x34
5 = 0x3C
6 = 0x44

Vertically, I think I want to avoid spawning enemies on the first/last pf line;
this gives us 13 possible vertical spawn positions, 7 if we do "on grid" spawns

In total, that's 28 PF2 spawn points

For PF1 spawns, these bit patterns are "on grid"

0x06 -> x = +-0x28 + 0x40
0x18 -> x = +-0x30 + 0x40

That's 14 PF1 spawn points, or 28 total

Together, it makes 56 spawn checks

Algo time!

8 x pos, 7 y pos: 3 bits x, 3 bits y

x bits:

0?? PF2 check
0xx PF2 check type
1?? PF1 check
10? PF1L
11? PF1R
1?x PF1 check type

y bits:
if 7 -> 3, then
0-6 = line * 2 + 1

    
Text: 
load text into ram via loop
 36.48
 40.55
unroll once
 36.48
 39.71
    
Items:
Rupees 1x, 5x
R. Heart
Fairy
Bombs
-- End of Random Drops --
Key
Triforce
Sword, White Sword
Master Sword
Candle (Red Blue?)
Rock Sirloin
Pegasus Boots (ladder)
Red Ring, Blue Ring
Potion
Raft
Magic Key
Bow
Arrow, Silver Arrow
Bracelet, Bracelet Lv2
Recorder?

; ASM TRICKS
sbc = adc(~arg)
; dec to target amount
    lda #$00 ; <- Target Value
    cmp v
    lda v
    sbc #$0
    sta v
    
; inc to target amount+1
    lda #$00 ; FF loops indefinitely
    cmp itemRupees
    lda itemRupees
    sbc #$FF
    sta itemRupees
    
Text24 draws 24 characters on a line every 2 frames, but it consumed most of
the rom I budgeted for text, without even storing text in the rom yet. It also
used 24 bytes of ram, which is a ton. when i looked at the code, i discovered
two subroutines, one for frame 1, one for frame 2, which were nearly identical.
The main difference was that one needed a 4 cycle delay while the other needed
a 6 cycle delay to position the sprite data correctly. I was able to
deduplicate the code by using the overflow flag to store whether the delay
should be 4 or 6 cycles long. A branch takes 2 cycles to execute, 3 if the
branch is taken, and so a pair of bvs is enough to implement a variable cycle
delay of 4/6 cycles.

MesgId/Mesg table rethink:

MesgId:
 1111 11xx - mesgId
 xxxx xx11 - partial bank index;
 xxxx xx1x - Loop iteration; 0 is top line, 1 is bottom line
 xxxx xxx1 - Frame bit; 0 = MesgB frame, 1 = MesgA frame


   Caves

   EX bits
   $FC = Cave Type/Dialog
   $03 = Variable

   Shop masks are overlapped
   $FC = Shop Type ($10, $14, $18)
   $0F = Shop Inventory

Secret
    Warp
    Hint
    Money
Shops
    B Pot,  Fairy,  R Pot
    Key,    Ring,   Meat
    Shield, Bomb,   Arrow
    Shield, Meat,   Heart
    Shield, Key,    Candle


E7 -> 3E conversion

Ram 

WorldKernel $ 90
PF          $ 3C
RoomClear   $ 20 for 256 rooms
RoomFlag    $100

Rom

World Data could be packed into $400 bytes per 128 rooms,
instead of $800 per 256. This could require less bank switching

Cart Ram Map Info:

General Layout

 A = F000 - Free
 B = F400 - Free
 C = F800 - World # Ram
 D = FC00 - "Always" bank

 Drawing

 A = F000 - Text Kernel A / Shop Kernel    / Sprites (Draw)
 B = F400 - Text Kernel B / Sprites (Shop) / Draw Kernel
 C = F800 - World # Ram
 D = FC00 - "Always" bank

 World Editor

Q, W, E - inc Room Tile  Left, Mid, Right
A, S, D - dec Room Tile  Left, Mid, Right
R, T    - inc, dec Room Script
F, G    - inc, dec, Room Ex
P       - Save
M       - switch active world
L       - Set Doorflags (4 char string of chars 0-3)
Z       - copy tile
Space   - place copied room
C       - Set room color (hex code)
Delete  - Delete room
1, 2, 3, 4 - Change N/S/W/E room door

Atan2 table lookup:
    dx = plX - mX
    dy = plY - mY

    if dx is negative
        xsign |= $80
        negate dx

    if dy is negative
        ysign |= $40
        negate dy

    while (dx > 7 or dy > 7)
        dx >>= 1
        dy >>= 1

    index = y * 8 + x
    index |= xsign
    index |= ysign

    if x == 0, inc y by $100 ; Solves Atan2 being undefined for 0/0
    else if y == 0, inc x by $100